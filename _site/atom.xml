<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>The Katana Programming Language</title>
 <link href="http://katanalang.org/atom.xml" rel="self"/>
 <link href="http://katanalang.org"/>
 <updated>2012-05-14T19:36:50-03:00</updated>
 <id>http://katanalang.org</id>
 <author>
   <name>Marco Aur√©lio</name>
   <email></email>
 </author>

 
 <entry>
   <title>Why I am Creating a Programming Language</title>
   <link href="http://katanalang.org/meta/2012/05/14/why-I-am-creating-a-language"/>
   <updated>2012-05-14T00:00:00-03:00</updated>
   <id>http://katanalang.org/meta/2012/05/14/why-I-am-creating-a-language</id>
   <content type="html">&lt;p&gt;&lt;img src='http://imgs.xkcd.com/comics/standards.png' alt='XKCD Comic on Standards' /&gt;&lt;/p&gt;

&lt;h2 id='an_unusual_week'&gt;An unusual week&lt;/h2&gt;

&lt;p&gt;If you are a frequent Hacker News visitor who is interested in programming language design, this week has probably not gone unnoticed to you: &lt;strong&gt;Two new programming languages&lt;/strong&gt; were introduced: &lt;a href='http://blog.lse.epita.fr/articles/12-c---system-oriented-programming.html'&gt;C!&lt;/a&gt; and &lt;a href='http://mbebenita.github.com/Mvm/'&gt;&amp;#42;JS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before I jump right in and introduce a &lt;em&gt;third one&lt;/em&gt;, I would like to comment on something that surprised me this week: The &lt;strong&gt;unusually positive reception&lt;/strong&gt; given to these languages.&lt;/p&gt;

&lt;h2 id='a_warm_welcome'&gt;A warm welcome&lt;/h2&gt;

&lt;p&gt;Over the years I&amp;#8217;ve grown accustomed to the reception new programming languages usually get, to the point where I instinctively recoil when I see a new programming language being announced. You consistently get phrases like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;#8220;We don&amp;#8217;t need yet another programming language!&amp;#8221;;&lt;/li&gt;

&lt;li&gt;&amp;#8220;I can already do that in &lt;b&gt;X&lt;/b&gt;!&amp;#8221;;&lt;/li&gt;

&lt;li&gt;&amp;#8220;You&amp;#8217;re only contributing to rework and fragmentation&amp;#8221;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Putting aside the occasional snarky comment, what I saw this week was the exact opposite of this: &lt;strong&gt;Insightful discussion and motivating posts&lt;/strong&gt;. The following comment (by Hacker News user antirez on the introduction of C!) specifically caught my attention:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;#8220;I would love to see ten attempts every year, trying to solve the same problem &amp;#91;system programming&amp;#93;.&amp;#8221;&lt;/em&gt; (&lt;a href='http://news.ycombinator.com/item?id=3948808'&gt;Source&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;This exactly sums up my feelings about designing new languages.&lt;/p&gt;

&lt;h2 id='you_might_not_notice_it_was_broken_until_someone_fixes_it'&gt;You might not notice it was broken until someone fixes it&lt;/h2&gt;

&lt;p&gt;We need new programming languages. Why do we need them? Because statements taking the form &lt;strong&gt;we don&amp;#8217;t need X&lt;/strong&gt; are, very often, wrong in hindsight. To give a few examples:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Before JSON was &lt;a href='http://inkdroid.org/journal/2012/04/30/lessons-of-json/'&gt;discovered&lt;/a&gt;, an easy thought for someone using XML would be that &amp;#8220;we don&amp;#8217;t need more formats to represent structured data in plain text&amp;#8221;;&lt;/li&gt;

&lt;li&gt;Before the iPhone launched (and keep in mind that was only five years ago), a whole industry had a very clear picture of what were and what were not the needs of their customers. Needless to say, they were pretty much wrong. Today&amp;#8217;s marketshare leader (Android) didn&amp;#8217;t even exist then;&lt;/li&gt;

&lt;li&gt;Same goes for the iPad (&lt;em&gt;&amp;#8220;we don&amp;#8217;t need another tablet&amp;#8221;&lt;/em&gt;);&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.extremetech.com/computing/79620-who-cares-about-googles-chrome-browser'&gt;We don&amp;#8217;t need&lt;/a&gt; &lt;a href='http://untyped.com/untyping/2008/09/02/googles-chrome-browser/'&gt;another browser&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='programming_languages_are_not_ac_chargers'&gt;Programming languages are not A/C chargers&lt;/h2&gt;

&lt;p&gt;The &lt;a href='http://xkcd.com/927/'&gt;xkcd comic&lt;/a&gt; on the beginning of this post (one of my personal favorites) has a pretty good point on the creation of new standards: When you create a new standard to address the problems of the existing &lt;em&gt;n&lt;/em&gt; standards, &lt;strong&gt;you end up with &lt;em&gt;n+1&lt;/em&gt; standards.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;That&amp;#8217;s a real nuisance when you have to &lt;a href='http://en.wikipedia.org/wiki/AC_power_plugs_and_sockets#Types_in_present_use'&gt;plug an electric equipment you got from abroad to your outlet&lt;/a&gt;, or when the text of a Web page &lt;a href='http://en.wikipedia.org/wiki/Mojibake'&gt;shows up garbled&lt;/a&gt; because someone messed up with their encodings.&lt;/p&gt;

&lt;p&gt;When it comes to programming, having &lt;em&gt;n+1&lt;/em&gt; languages is &lt;strong&gt;not a nuisance&lt;/strong&gt;. If you think it is, you might be confusing programming languages with execution environments. For instance, calling C code from Java can be quite annoying because Java code runs on the JVM, while C code runs natively. Calling Scala code from Java or vice versa &lt;a href='http://www.codecommit.com/blog/java/interop-between-java-and-scala'&gt;is actually pretty straightforward&lt;/a&gt;. So is calling JavaScript from CoffeeScript. Or C from Objective-C, C++ or D.&lt;/p&gt;

&lt;p&gt;Programming languages are not like A/C chargers. They are &lt;strong&gt;tools for human expression&lt;/strong&gt;; and as such, you can never really have enough of them.&lt;/p&gt;

&lt;h2 id='its_not_rework_if_its_not_work'&gt;It&amp;#8217;s not rework if it&amp;#8217;s not work&lt;/h2&gt;

&lt;p&gt;What about &lt;strong&gt;all the rework&lt;/strong&gt; that goes into a new programming language? After all, you have to specify the grammar and semantics, write a compiler, debug it, write a run-time library, debug it, write a standard library, debug it&amp;#8230; The list goes on indefinitely. From a pure cost/benefit perspective that time could sure be better spent on something else.&lt;/p&gt;

&lt;p&gt;But then I ask you, why do people still paint? Anyone could surely hit Google &lt;a href='http://www.google.com/search?q=still+life'&gt;with a search for still life&lt;/a&gt;, copy the top image result and print it on a A3 sheet; it would be much cheaper than the cost of even a single canvas. But people still paint because painting is an intellectual endeavor: a &lt;em&gt;pretty fun&lt;/em&gt; intellectual endeavor.&lt;/p&gt;

&lt;p&gt;Coding is very much like painting. It can be work, but it can also be a past-time. Creating a new programming language can be really fun, and as a bonus you get to learn a lot about the fundamentals of computing.&lt;/p&gt;

&lt;h2 id='im_not_smart_enough_to_create_the_ideal_language_and_i_dont_care'&gt;I&amp;#8217;m not smart enough to create the ideal language, and I don&amp;#8217;t care&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://en.wikipedia.org/wiki/Universal_Darwinism'&gt;Universal darwinism&lt;/a&gt; is the extension of Darwinism to fields other than biological evolution. On &lt;a href='http://www.ted.com/talks/susan_blackmore_on_memes_and_temes.html'&gt;this TED Talk&lt;/a&gt;, Susan Blackmore elaborates on how &lt;strong&gt;human ideas are subject to natural selection&lt;/strong&gt; just like living things. In fact, she states that whenever you have three fundamental factors in place &amp;#8212; variation, selection and heredity &amp;#8212; with enough time, design arises spontaneously.&lt;/p&gt;

&lt;p&gt;Programming languages are subject to all of the three factors: Whenever you create a new programming language you add &lt;em&gt;variation&lt;/em&gt;; since languages are inspired by other languages, you have &lt;em&gt;heredity&lt;/em&gt;; finally, &lt;em&gt;selection&lt;/em&gt; takes place thanks to popularity/obscurity. That means that us, mere mortals, can still contribute to the overall landscape of programming languages even if we&amp;#8217;re not white-bearded wizards, simply by &lt;em&gt;trying&lt;/em&gt;. That is enough motivation for me to create a programming language. And I think you should try it too.&lt;/p&gt;

&lt;h2 id='enter_katana'&gt;Enter Katana&lt;/h2&gt;

&lt;p&gt;Katana is a new programming language I&amp;#8217;m working on. Its goal is to mix high level JavaScript-like semantics with C in a natively compiled language that still favors performance and predictability. Possible applications include games, web servers, compilers and embed systems. Over the next few weeks I&amp;#8217;ll post more details on the thought process behind the language as well on the progress being made with the compiler.&lt;/p&gt;

&lt;p&gt;&lt;img src='/assets/images/logo.png' alt='Katana Logo' /&gt;&lt;/p&gt;</content>
 </entry>
 
 
</feed>